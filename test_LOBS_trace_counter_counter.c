//test_LOBS_trace_counter_counter.c

#include "sys_platform.h"
#include "LOBS_integration_trigger_def.h"

#define GRP_WIDTH            128
#define RAM_ADDR_SIZE        25
#define TRACE_GEN            1
#define SECURE_MODE          1
#define COND_TRIG            1
#define ID_CAPTURE_SIZE      10
#define ID_CAPTURE_GEN       1
#define NUM_TRIG_STATES      5
#define EXPERT_MASK          0
#define MASK_GRP             0
#define E_SHIFT              2
#define TRIGIN_EDGE          0
#define COUNTER_MATCH        3

int main(int argc, char *argv[])
{
  uint32_t i,j,temp;
  i = 0;
  j=0;
  //open  clock
	ENABLE_RESOURCE(LINK_INDEX_GPIO );
	
	ENABLE_RESOURCE(LINK_INDEX_LOBS ); 
		 PRINTF("test Clock initialization - waiting for PLLs locked");
	wait_delay (1000);
    // initail GPIO excitation 
	TRIGGER_SET(TRIGGER_TB_CONNECT_LOBS_OPT0);
	//config all LOBS
	// unlock LOBS
	REG32_WRITE(MAP_BASE_LOBS+LOBS_LAR, 0xC5ACCE55);
	if (REG32(MAP_BASE_LOBS+LOBS_LSR) != 1) {PRINTF("d=Debug,unlock fail!");}
// Initialize external signal Compare and Masks to all 0s.
	for (i = 0; i < NUM_TRIG_STATES; i = i + 1)
{
    REG32_WRITE(MAP_BASE_LOBS + (LOBS_EXTCOMP0 + (i << 8)), 0x00);
    REG32_WRITE(MAP_BASE_LOBS + (LOBS_EXTMASK0 + (i << 8)), 0x00);
}
	//config HRAM ADDRESSMAP_BASE_LOBS

    REG32_WRITE(MAP_BASE_LOBS+STARTADDR, MAP_BASE_HDMA);
    REG32_WRITE(MAP_BASE_LOBS+ENDADDR,MAP_BASE_HDMA+RAM_ADDR_SIZE*32);
	//config 
	temp=REG32(MAP_BASE_LOBS+LOBS_DEVID1);
	PRINTF("LOBS_DEVID1 is %x",temp);
// globe reg conif
    REG32_WRITE(MAP_BASE_LOBS+LOBS_PTACTION, 0x8);
// trigger state 0
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGSEL0, Group0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_TRIGCTRL0, 0xa9);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_NEXTSTATE0, State1) ;
    REG32_WRITE(MAP_BASE_LOBS + LOBS_ACTION0, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTNEXTSTATE0,Keep_State);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTACTION0, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_COUNTCOMP0, 0x000f);
// signal group 0 
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP0_00, 0x0000000f);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP0_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK0_00, 0x00000fff);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK0_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP0_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP0_11, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK0_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK0_11, 0x0);	
// trigger state 1
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGSEL1, Group0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_TRIGCTRL1, 0xa9);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_NEXTSTATE1, State2) ;
    REG32_WRITE(MAP_BASE_LOBS + LOBS_ACTION1, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTNEXTSTATE1,Keep_State);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTACTION1, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_COUNTCOMP1, 0x000f);
// signal group 1 
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP1_00, 0x0000000f);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP1_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK1_00, 0x00000fff);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK1_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP1_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP1_11, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK1_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK1_11, 0x0);	
// trigger state 2
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGSEL2, Group0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_TRIGCTRL2, 0xa9);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_NEXTSTATE2, State3) ;
    REG32_WRITE(MAP_BASE_LOBS + LOBS_ACTION2, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTNEXTSTATE2,Keep_State);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTACTION2, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_COUNTCOMP2, 0x000f);
// signal group 2 
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP2_00, 0x0000000f);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP2_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK2_00, 0x00000fff);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK2_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP2_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP2_11, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK2_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK2_11, 0x0);	
// trigger state 3
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGSEL3, Group0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_TRIGCTRL3, 0xa9);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_NEXTSTATE3, State4) ;
    REG32_WRITE(MAP_BASE_LOBS + LOBS_ACTION3, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTNEXTSTATE3, Keep_State);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTACTION3, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_COUNTCOMP3, 0x000f);
// signal group 3 
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP3_00, 0x0000000f);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP3_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK3_00, 0x00000fff);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK3_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP3_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP3_11, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK3_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK3_11, 0x0);	
// trigger state 4
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGSEL4, Group0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_TRIGCTRL4, 0xa9);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_NEXTSTATE4, Keep_State) ;
    REG32_WRITE(MAP_BASE_LOBS + LOBS_ACTION4, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTNEXTSTATE4, Keep_State);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_ALTACTION4, 0x0);
	REG32_WRITE(MAP_BASE_LOBS + LOBS_COUNTCOMP4, 0x000f);
// signal group 4 
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP4_00, 0x0000000f);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP4_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK4_00, 0x00000fff);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK4_01, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP4_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGCOMP4_11, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK4_10, 0x0);
    REG32_WRITE(MAP_BASE_LOBS + LOBS_SIGMASK4_11, 0x0);	
	// run
	REG32_WRITE(MAP_BASE_LOBS + LOBS_CTRL, 1);
	
	// temp = REG32(MAP_BASE_LOBS +LOBS_CTSR); 
		while ( (REG32(MAP_BASE_LOBS +LOBS_CTSR) >> 31) != 1 )
		{
			//PRINTF("LOBS_CTSR is final state");
			/* code */
		}
		
	REG32_WRITE(MAP_BASE_LOBS+LOBS_CTRL, 0);
	wait_delay (1000);
	// Determine whether the result is correct
	//
		return 2;
/*	if (j>1)
	{
		sys_cvc_error();
		return 1;
	}
	else{
		return 2;
	}*/

 }
